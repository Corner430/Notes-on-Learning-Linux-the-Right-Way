# Shell 中常用的转义字符
在Shell中，**转义字符是用来改变特定字符的原始含义**，使其具有特殊的意义或功能。转义字符**通常以反斜杠 `\` 开头**，后跟特定的字符。下面是一些Shell中常用的转义字符：
  1. 反斜杠 `\`：**反斜杠本身就是一个转义字符。当在一个字符前面添加反斜杠时，它会取消该字符的特殊含义**，使其被视为普通字符。例如，`\'` 将把单引号变成普通的单引号。
  2. 单引号 `'`：**在单引号内部的所有字符都会被视为普通字符，不会进行转义。这意味着单引号可以用来保留文本的原始形式**。
  3. 双引号 `"`：**在双引号内部，一些字符会保留其特殊含义，例如 `$` 和反引号 `` ` ``，用于变量展开和命令替换。同时，可以在双引号中使用反斜杠来转义字符**。
  4. `$` 符号：`$` 符号**用于变量的展开**。在双引号中，`$` 后跟一个变量名将展开为变量的值。
  5. 反引号 `` ` ``：**反引号用于执行命令替换。在反引号内部的命令会被执行，并将输出插入到命令的位置**。
     ```
     echo "Today is `date`" # 输出：Today is <当前日期和时间>
     ```
  6. `\n`：`\n` 是一个特殊的转义序列，表示换行。它会在文本中插入一个换行符，实现换行的效果。

# 5种重定向技术
- 标准覆盖输出重定向
- 标准追加输出重定向
- 错误覆盖输出重定向
- 错误追加输出重定向
- 输入重定向

> 简而言之，**输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。输出重定向的频率更高**。

- 标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入
- 标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕
- 错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕

#### 输入重定向中用到的符号及其作用
| 符号 | 作用 |
|:--------:|:--------:|
| 命令 < 文件 | 将文件作为命令的标准输入 |
| 命令 << 分界符 | 从标准输入中读入，直到遇见分界符才停止 |
| 命令 < 文件1 > 文件2 | **将文件1作为命令的标准输入并将标出输出到文件2** |

#### 输出重定向中用到的符号及其作用
| 符号 | 作用 |
|:--------:|:--------:|
| 命令 > 文件 | 将**标准**输出重定向到一个文件中（清空原有文件的数据） |
| 命令 2> 文件 | 将**错误**输出重定向到一个文件中（清空原有文件的数据） |
| 命令 >> 文件 | 将**标准**输出重定向到一个文件中（追加到原有内容的后面） |
| 命令 2>> 文件 | 将**错误**输出重定向到一个文件中（追加到原有内容的后面） |
| 命令 >> 文件 2>&1 **或者** 命令 &>> 文件 | 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） |
> 对于重定向中的标准输出模式，可以省略文件描述符1不写，而错误输出模式的文件描述符2是必须要写的


# 管道命令符
在Linux中，管道符 `|` 是一种特殊的字符，**用于将一个命令的输出连接到另一个命令的输入。这种机制称为"管道"**，它是一种非常强大和灵活的功能，允许将多个命令组合在一起，以便进行数据处理和操作。

管道的基本用法是在命令之间使用 `|` 字符。**命令在管道中的运行顺序是从左到右。左边的命令的输出会成为右边命令的输入**。这样可以将多个命令链接在一起，实现更复杂的数据处理需求。

以下是管道符 `|` 的一些常见用法：
  1. 筛选数据：
     ```
     ls -l | grep "file.txt"
     ```
     这个命令会列出当前目录下的所有文件，并将结果通过管道传递给 `grep` 命令。`grep` 命令将筛选出包含 "file.txt" 的文件。
  2. 统计数据：
     ```
     cat file.txt | wc -l
     ```
     这个命令会将 `file.txt` 文件的内容通过管道传递给 `wc -l` 命令，`wc -l` 命令会统计文件的行数。
  3. 结合多个命令：
     ```
     ps aux | grep "firefox" | grep -v "grep" | awk '{print $2}'
     ```
     这个命令将会列出所有运行中的进程，并通过管道传递给 `grep` 命令，`grep` 命令将筛选出包含 "firefox" 的进程。然后，`grep -v "grep"` 命令会排除包含 "grep" 的行。最后，通过管道传递给 `awk` 命令，`awk '{print $2}'` 会输出进程的PID（进程ID）。


# 命令行的通配符
命令行中的通配符是用于匹配文件和目录名称的特殊字符。**它们允许用户在执行命令时指定一组符合特定模式的文件或目录，而不需要列出每个文件的完整名称**。通配符在Linux和Unix系统的命令行中广泛使用，使命令的操作更加灵活和便捷。

以下是常见的命令行通配符：
  1. 星号 `*`：星号是最常用的通配符，它表示匹配任意字符序列（包括空字符序列）。在命令行中，星号通配符可用于匹配**任意长度**的文件或目录名称。
  2. 问号 `?`：问号通配符表示匹配**任意单个**字符。
  3. 方括号 `[ ]`：**方括号通配符允许指定一个字符集合中的一个字符。可以在方括号中列出多个字符，其中任意一个字符都会匹配**。
     ```
     ls file[123].txt # 匹配 "file1.txt"、"file2.txt" 和 "file3.txt"
     ```
  4. 花括号 `{ }`：**花括号通配符允许指定多个选项，用逗号分隔。命令会展开为所有可能的组合**。
     ```
     mv {a,b,c}.txt destination_folder # 将 "a.txt"、"b.txt" 和 "c.txt" 移动到 destination_folder 目录中
     ```
  5. 反斜杠 `\`：**反斜杠可以用于取消通配符的特殊含义，将其视为普通字符**。
     ```
     ls \*.txt # 列出所有以 ".txt" 结尾的文件
     ```


# Shell脚本
下面是编写Shell脚本的基本步骤：
  1. 创建脚本文件：创建一个新的脚本文件，文件名以 `.sh` 结尾，例如 `myscript.sh`。**Shell脚本文件的名称可以任意**，但是通常以 `.sh` 结尾，以便于识别。
  2. 添加Shebang行：在脚本文件的第一行添加Shebang行，指定要用于解释执行脚本的Shell。对于Bash脚本，Shebang行应为：`#!/bin/bash`
  3. 编写脚本内容：在脚本文件中添加Shell脚本的内容。这些内容可以包括命令、变量、条件语句、循环等，以完成特定的任务。
  4. 赋予执行权限：在保存完脚本文件后，需要赋予执行权限，以便可以运行脚本。使用以下命令为脚本文件添加执行权限：`chmod +x myscript.sh`
  5. 运行脚本：现在，可以通过以下方式运行Shell脚本：`./myscript.sh`
     或者使用`bash`命令运行：`bash myscript.sh`
     或者使用`source`命令运行（如果脚本中包含了需要在当前Shell中执行的命令）：`source myscript.sh`
     注意，`source`命令也可以用点号（`.`）来代替，例如：`. myscript.sh`。


# Shell脚本接收用户参数
**在Shell脚本中，可以通过特定的变量来接收用户传递的参数。这些特定变量在Shell中被称为"位置参数"，用于获取脚本执行时传递的参数值**。在常见的Shell中，这些位置参数由 `$1`、`$2`、`$3`，依此类推，表示第一个参数、第二个参数、第三个参数，以此类推。

下面是一个简单的例子，演示如何在Shell脚本中接收用户传递的参数：

```bash
#!/bin/bash

# $0 表示脚本本身的名称，例如：./myscript.sh
echo "脚本名称：$0"

# $1 表示第一个参数，例如：./myscript.sh argument1
echo "第一个参数：$1"

# $2 表示第二个参数，例如：./myscript.sh argument1 argument2
echo "第二个参数：$2"

# $3 表示第三个参数，例如：./myscript.sh argument1 argument2 argument3
echo "第三个参数：$3"

# $* 表示所有参数的列表，以单个字符串表示
echo "所有参数：$*"

# $# 表示参数的数量
echo "参数的数量：$#"
```

例如，如果将上述脚本保存为 `myscript.sh` 并通过命令行执行：

```bash
./myscript.sh apple banana orange
```

输出将会是：

```
脚本名称：./myscript.sh
第一个参数：apple
第二个参数：banana
第三个参数：orange
所有参数：apple banana orange
参数的数量：3
```


# `$?`
**`$?` 变量用于获取上一个命令的退出状态**。在Shell脚本中，如果你想要检查上一个命令是否成功执行，可以使用 `$?` 变量。如果上一个命令成功执行，`$?` 的值将会是 `0`，否则将会是一个非零值。



# Shell中的条件表达式
**Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则返回非0值。条件测试语法的执行格式为：`[ expression ]`，注意，表达式两边的方括号与表达式之间必须有空格**。
按照测试对象来划分，条件测试语句可以分为4种：
  - **文件测试语句**：用于测试文件的属性，例如文件是否存在、是否是目录、是否可读等。
  - **逻辑测试语句**：用于测试逻辑表达式，例如两个数是否相等、是否大于等于等。
  - **整数值比较语句**：用于测试整数值的大小关系，例如一个数是否大于另一个数。
  - **字符串比较语句**：用于测试字符串的大小关系，例如一个字符串是否大于另一个字符串。

> 常用的文件测试运算符和它们的作用：

| 运算符  | 作用                                                         |
|:---------:|:--------------------------------------------------------------:|
| -e 文件 | 检查文件是否存在                                             |
| -f 文件 | 检查文件是否为普通文件                                       |
| -d 文件 | 检查文件是否为目录                                           |
| -s 文件 | 检查文件是否非空                                             |
| -r 文件 | 检查文件是否可读                                             |
| -w 文件 | 检查文件是否可写                                             |
| -x 文件 | 检查文件是否可执行                                           |
| 文件1 -nt 文件2 | 检查文件1是否比文件2新（"newer than"的缩写）       |
| 文件1 -ot 文件2 | 检查文件1是否比文件2旧（"older than"的缩写）       |
| -O 文件 | 检查文件是否属于当前用户（effective user id）              |
| -G 文件 | 检查文件是否属于当前用户所属的组（effective group id）     |
| 文件1 -ef 文件2 | 检查文件1是否和文件2为同一个硬链接（"equivalent to"的缩写）|

> 当在Shell脚本中进行条件测试时，逻辑测试用于组合多个条件，并根据条件的组合结果决定执行不同的操作。常用的逻辑测试运算符有两种：逻辑与（AND）和逻辑或（OR）。以下是逻辑测试运算符的使用和作用：

| 运算符     | 作用                                                                                   |
|:---------:|:--------------------------------------------------------------------------------------:|
| 表达式1 -a 表达式2 | 逻辑与，检查同时满足表达式1和表达式2的条件是否成立                                   |
| 表达式1 -o 表达式2 | 逻辑或，检查满足表达式1或表达式2中任意一个条件是否成立                                 |
| ! 表达式    | 逻辑非，取反，检查表达式的条件是否不成立                                              |

>  `&&` 和 `||` 运算符的使用和作用：

- `command1 && command2`：逻辑与，如果 `command1` 成功执行（即返回退出状态码为0），则执行 `command2`。

- `command1 || command2`：逻辑或，如果 `command1` 失败执行（即返回退出状态码为非零值），则执行 `command2`。

在使用 `&&` 和 `||` 运算符时，需要注意的是，**它们并不是条件测试运算符，而是用于根据前一个命令的退出状态码决定是否执行后一个命令**。

> 常用的整数值比较运算符和它们的作用：

| 运算符 | 作用                                                      |
|:---------:|:-----------------------------------------------------:|
| -eq    | 等于（equal），检查两个整数是否相等                        |
| -ne    | 不等于（not equal），检查两个整数是否不相等                |
| -gt    | 大于（greater than），检查第一个整数是否大于第二个整数     |
| -lt    | 小于（less than），检查第一个整数是否小于第二个整数        |
| -ge    | 大于等于（greater than or equal），检查第一个整数是否大于等于第二个整数 |
| -le    | 小于等于（less than or equal），检查第一个整数是否小于等于第二个整数    |

> 常用的字符串比较运算符和它们的作用：

| 运算符 | 作用                                                                  |
|:---------:|:-----------------------------------------------------------------:|
| =      | 检查两个字符串是否相等                                                |
| !=     | 检查两个字符串是否不相等                                              |
| -z     | 检查字符串是否为空（长度为0）                                         |
| -n     | 检查字符串是否非空（长度大于0）                                       |
| str    | 检查字符串是否非空（与 -n 运算符类似，但不需要 -n 修饰符，直接写字符串即可）  |



# 流程控制语句之 if 语句
多分支的 if 语句：
```bash
if [ 条件1 ]
then
    command1
elif [ 条件2 ]
then
    command2
else
    command3
fi
```

# 流程控制语句之 for 语句
```bash
for 变量 in 取值列表
do
    command
done
```

# 流程控制语句之 while 语句
```bash
while [ 条件 ]
do
    command
done
```

# 流程控制语句之 case 语句
```bash
case $变量名 in
    取值1)
        command1
        ;;
    取值2)
        command2
        ;;
    *)
        command3
        ;;
esac
```