#### 12. 5种重定向技术
- 标准覆盖输出重定向
- 标准追加输出重定向
- 错误覆盖输出重定向
- 错误追加输出重定向
- 输入重定向

> 简而言之，**输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。输出重定向的频率更高**。

- 标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入
- 标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕
- 错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕

##### 输入重定向中用到的符号及其作用
| 符号 | 作用 |
|:--------:|:--------:|
| 命令 < 文件 | 将文件作为命令的标准输入 |
| 命令 << 分界符 | 从标准输入中读入，直到遇见分界符才停止 |
| 命令 < 文件1 > 文件2 | **将文件1作为命令的标准输入并将标出输出到文件2** |

##### 输出重定向中用到的符号及其作用
| 符号 | 作用 |
|:--------:|:--------:|
| 命令 > 文件 | 将**标准**输出重定向到一个文件中（清空原有文件的数据） |
| 命令 2> 文件 | 将**错误**输出重定向到一个文件中（清空原有文件的数据） |
| 命令 >> 文件 | 将**标准**输出重定向到一个文件中（追加到原有内容的后面） |
| 命令 2>> 文件 | 将**错误**输出重定向到一个文件中（追加到原有内容的后面） |
| 命令 >> 文件 2>&1 **或者** 命令 &>> 文件 | 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） |
> 对于重定向中的标准输出模式，可以省略文件描述符1不写，而错误输出模式的文件描述符2是必须要写的

#### 13. 管道命令符
在Linux中，管道符 `|` 是一种特殊的字符，**用于将一个命令的输出连接到另一个命令的输入**。这种机制称为"管道"，它是一种非常强大和灵活的功能，允许将多个命令组合在一起，以便进行数据处理和操作。

管道的基本用法是在命令之间使用 `|` 字符。**命令在管道中的运行顺序是从左到右。左边的命令的输出会成为右边命令的输入**。这样可以将多个命令链接在一起，实现更复杂的数据处理需求。

以下是管道符 `|` 的一些常见用法：
  1. 筛选数据：
     ```
     ls -l | grep "file.txt"
     ```
     这个命令会列出当前目录下的所有文件，并将结果通过管道传递给 `grep` 命令。`grep` 命令将筛选出包含 "file.txt" 的文件。
  2. 统计数据：
     ```
     cat file.txt | wc -l
     ```
     这个命令会将 `file.txt` 文件的内容通过管道传递给 `wc -l` 命令，`wc -l` 命令会统计文件的行数。
  3. 结合多个命令：
     ```
     ps aux | grep "firefox" | grep -v "grep" | awk '{print $2}'
     ```
     这个命令将会列出所有运行中的进程，并通过管道传递给 `grep` 命令，`grep` 命令将筛选出包含 "firefox" 的进程。然后，`grep -v "grep"` 命令会排除包含 "grep" 的行。最后，通过管道传递给 `awk` 命令，`awk '{print $2}'` 会输出进程的PID（进程ID）。

#### 14. 命令行的通配符
命令行中的通配符是用于匹配文件和目录名称的特殊字符。**它们允许用户在执行命令时指定一组符合特定模式的文件或目录，而不需要列出每个文件的完整名称**。通配符在Linux和Unix系统的命令行中广泛使用，使命令的操作更加灵活和便捷。

以下是常见的命令行通配符：
  1. 星号 `*`：星号是最常用的通配符，它表示匹配任意字符序列（包括空字符序列）。在命令行中，星号通配符可用于匹配**任意长度**的文件或目录名称。
  2. 问号 `?`：问号通配符表示匹配**任意单个**字符。
  3. 方括号 `[ ]`：**方括号通配符允许指定一个字符集合中的一个字符。可以在方括号中列出多个字符，其中任意一个字符都会匹配**。
     ```
     ls file[123].txt # 匹配 "file1.txt"、"file2.txt" 和 "file3.txt"
     ```
  4. 花括号 `{ }`：**花括号通配符允许指定多个选项，用逗号分隔。命令会展开为所有可能的组合**。
     ```
     mv {a,b,c}.txt destination_folder # 将 "a.txt"、"b.txt" 和 "c.txt" 移动到 destination_folder 目录中
     ```
  5. 反斜杠 `\`：**反斜杠可以用于取消通配符的特殊含义，将其视为普通字符**。
     ```
     ls \*.txt # 列出所有以 ".txt" 结尾的文件
     ```

#### 15. Shell 中常用的转义字符
在Shell中，转义字符是用来改变特定字符的原始含义，使其具有特殊的意义或功能。转义字符通常以反斜杠 `\` 开头，后跟特定的字符。下面是一些Shell中常用的转义字符：
  1. 反斜杠 `\`：**反斜杠本身就是一个转义字符。当在一个字符前面添加反斜杠时，它会取消该字符的特殊含义**，使其被视为普通字符。例如，`\'` 将把单引号变成普通的单引号。
  2. 单引号 `'`：**在单引号内部的所有字符都会被视为普通字符，不会进行转义。这意味着单引号可以用来保留文本的原始形式**。
  3. 双引号 `"`：**在双引号内部，一些字符会保留其特殊含义，例如 `$` 和反引号 `` ` ``，用于变量展开和命令替换。同时，可以在双引号中使用反斜杠来转义字符**。
  4. `$` 符号：`$` 符号**用于变量的展开**。在双引号中，`$` 后跟一个变量名将展开为变量的值。
  5. 反引号 `` ` ``：**反引号用于执行命令替换。在反引号内部的命令会被执行，并将输出插入到命令的位置**。
     ```
     echo "Today is `date`" # 输出：Today is <当前日期和时间>
     ```
  6. `\n`：`\n` 是一个特殊的转义序列，表示换行。它会在文本中插入一个换行符，实现换行的效果。

#### 22. Shell脚本
下面是编写Shell脚本的基本步骤：
  1. 创建脚本文件：创建一个新的脚本文件，文件名以 `.sh` 结尾，例如 `myscript.sh`。**Shell脚本文件的名称可以任意**，但是通常以 `.sh` 结尾，以便于识别。
  2. 添加Shebang行：在脚本文件的第一行添加Shebang行，指定要用于解释执行脚本的Shell。对于Bash脚本，Shebang行应为：`#!/bin/bash`
  3. 编写脚本内容：在脚本文件中添加Shell脚本的内容。这些内容可以包括命令、变量、条件语句、循环等，以完成特定的任务。
  4. 赋予执行权限：在保存完脚本文件后，需要赋予执行权限，以便可以运行脚本。使用以下命令为脚本文件添加执行权限：`chmod +x myscript.sh`
  5. 运行脚本：现在，可以通过以下方式运行Shell脚本：`./myscript.sh`
     或者使用`bash`命令运行：`bash myscript.sh`
     或者使用`source`命令运行（如果脚本中包含了需要在当前Shell中执行的命令）：`source myscript.sh`
     注意，`source`命令也可以用点号（`.`）来代替，例如：`. myscript.sh`。
#### 23. Shell脚本接收用户参数
在Shell脚本中，你可以通过特定的变量来接收用户传递的参数。这些特定变量在Shell中被称为"位置参数"，用于获取脚本执行时传递的参数值。在常见的Shell中，这些位置参数由 `$1`、`$2`、`$3`，依此类推，表示第一个参数、第二个参数、第三个参数，以此类推。

下面是一个简单的例子，演示如何在Shell脚本中接收用户传递的参数：

```bash
#!/bin/bash

# $0 表示脚本本身的名称，例如：./myscript.sh
echo "脚本名称：$0"

# $1 表示第一个参数，例如：./myscript.sh argument1
echo "第一个参数：$1"

# $2 表示第二个参数，例如：./myscript.sh argument1 argument2
echo "第二个参数：$2"

# $3 表示第三个参数，例如：./myscript.sh argument1 argument2 argument3
echo "第三个参数：$3"

# $* 表示所有参数的列表，以单个字符串表示
echo "所有参数：$*"

# $# 表示参数的数量
echo "参数的数量：$#"
```

例如，如果将上述脚本保存为 `myscript.sh` 并通过命令行执行：

```bash
./myscript.sh apple banana orange
```

输出将会是：

```
脚本名称：./myscript.sh
第一个参数：apple
第二个参数：banana
第三个参数：orange
所有参数：apple banana orange
参数的数量：3
```

#### 24. `$?`
`$?` 变量用于获取上一个命令的退出状态。在Shell脚本中，如果你想要检查上一个命令是否成功执行，可以使用 `$?` 变量。如果上一个命令成功执行，`$?` 的值将会是 `0`，否则将会是一个非零值。

#### 25. Shell中的条件表达式
Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则返回非0值。条件测试语法的执行格式为：`[ expression ]`，注意，表达式两边的方括号与表达式之间必须有空格。
按照测试对象来划分，条件测试语句可以分为4种：
  - **文件测试语句**：用于测试文件的属性，例如文件是否存在、是否是目录、是否可读等。
  - **逻辑测试语句**：用于测试逻辑表达式，例如两个数是否相等、是否大于等于等。
  - **整数值比较语句**：用于测试整数值的大小关系，例如一个数是否大于另一个数。
  - **字符串比较语句**：用于测试字符串的大小关系，例如一个字符串是否大于另一个字符串。

> 常用的文件测试运算符和它们的作用：

| 运算符  | 作用                                                         |
|:---------:|:--------------------------------------------------------------:|
| -e 文件 | 检查文件是否存在                                             |
| -f 文件 | 检查文件是否为普通文件                                       |
| -d 文件 | 检查文件是否为目录                                           |
| -s 文件 | 检查文件是否非空                                             |
| -r 文件 | 检查文件是否可读                                             |
| -w 文件 | 检查文件是否可写                                             |
| -x 文件 | 检查文件是否可执行                                           |
| 文件1 -nt 文件2 | 检查文件1是否比文件2新（"newer than"的缩写）       |
| 文件1 -ot 文件2 | 检查文件1是否比文件2旧（"older than"的缩写）       |
| -O 文件 | 检查文件是否属于当前用户（effective user id）              |
| -G 文件 | 检查文件是否属于当前用户所属的组（effective group id）     |
| 文件1 -ef 文件2 | 检查文件1是否和文件2为同一个硬链接（"equivalent to"的缩写）|

> 当在Shell脚本中进行条件测试时，逻辑测试用于组合多个条件，并根据条件的组合结果决定执行不同的操作。常用的逻辑测试运算符有两种：逻辑与（AND）和逻辑或（OR）。以下是逻辑测试运算符的使用和作用：

| 运算符     | 作用                                                                                   |
|:---------:|:--------------------------------------------------------------------------------------:|
| 表达式1 -a 表达式2 | 逻辑与，检查同时满足表达式1和表达式2的条件是否成立                                   |
| 表达式1 -o 表达式2 | 逻辑或，检查满足表达式1或表达式2中任意一个条件是否成立                                 |
| ! 表达式    | 逻辑非，取反，检查表达式的条件是否不成立                                              |

>  `&&` 和 `||` 运算符的使用和作用：

- `command1 && command2`：逻辑与，如果 `command1` 成功执行（即返回退出状态码为0），则执行 `command2`。

- `command1 || command2`：逻辑或，如果 `command1` 失败执行（即返回退出状态码为非零值），则执行 `command2`。

在使用 `&&` 和 `||` 运算符时，需要注意的是，**它们并不是条件测试运算符，而是用于根据前一个命令的退出状态码决定是否执行后一个命令**。

> 常用的整数值比较运算符和它们的作用：

| 运算符 | 作用                                                      |
|:---------:|:-----------------------------------------------------:|
| -eq    | 等于（equal），检查两个整数是否相等                        |
| -ne    | 不等于（not equal），检查两个整数是否不相等                |
| -gt    | 大于（greater than），检查第一个整数是否大于第二个整数     |
| -lt    | 小于（less than），检查第一个整数是否小于第二个整数        |
| -ge    | 大于等于（greater than or equal），检查第一个整数是否大于等于第二个整数 |
| -le    | 小于等于（less than or equal），检查第一个整数是否小于等于第二个整数    |

> 常用的字符串比较运算符和它们的作用：

| 运算符 | 作用                                                                  |
|:---------:|:-----------------------------------------------------------------:|
| =      | 检查两个字符串是否相等                                                |
| !=     | 检查两个字符串是否不相等                                              |
| -z     | 检查字符串是否为空（长度为0）                                         |
| -n     | 检查字符串是否非空（长度大于0）                                       |
| str    | 检查字符串是否非空（与 -n 运算符类似，但不需要 -n 修饰符，直接写字符串即可）  |

#### 26. 流程控制语句之 if 语句
多分支的 if 语句：
```bash
if [ 条件1 ]
then
    command1
elif [ 条件2 ]
then
    command2
else
    command3
fi
```

#### 27. 流程控制语句之 for 语句
```bash
for 变量 in 取值列表
do
    command
done
```

#### 28. 流程控制语句之 while 语句
```bash
while [ 条件 ]
do
    command
done
```

#### 29. 流程控制语句之 case 语句
```bash
case $变量名 in
    取值1)
        command1
        ;;
    取值2)
        command2
        ;;
    *)
        command3
        ;;
esac
```

#### 30. 计划任务服务程序
计划任务分为**一次性计划任务**与**长期性计划任务**
- 一次性计划任务：只执行一次的计划任务，执行完毕后就会自动删除
  - [at: 在指定的时间执行指定的任务](https://wangchujiang.com/linux-command/c/at.html)
  - [atrm: 删除待执行的任务](https://wangchujiang.com/linux-command/c/atrm.html)
- 长期性计划任务：周期性执行的计划任务，执行完毕后不会自动删除
  - [crontab: 定时执行任务](https://wangchujiang.com/linux-command/c/crontab.html)
> 分、时、日、月、星期、命令
> 在crond服务的计划任务参数种，所有命令**一定要用绝对路径**的方式来写，如果不知道绝对路径，可以使用 `whereis` 或者 `which` 命令来查看
> 在crond服务的配置参数中，可以像Shell脚本那样以#开头添加注释，但是注释必须独占一行
> **计划任务中的“分”字段必须有数值，绝对不能为空或是星号（*），而“日”和“星期”字段不能同时使用，否则就会发生冲突**
> crond服务默认调用的是vim编辑器


#### 34. 文件权限与归属
在Linux系统中，一切都被视为文件，包括硬件设备、目录、文本文件、二进制文件等。为了区分不同类型的文件，Linux使用了不同的字符来表示它们的类型。以下是常见的字符及其含义：

1. `-`（短横线）：普通文件
   普通文件包含文本内容或二进制数据，通常用于存储用户数据、配置文件、程序代码等。

2. `d`：目录
   目录是用于组织文件和其他目录的特殊文件类型。它们包含其他文件和子目录。

3. `l`：符号链接（软链接）
   符号链接是指向另一个文件或目录的特殊文件类型，类似于Windows系统中的快捷方式。它们可以跨越文件系统和目录边界。

4. `c`：字符设备文件
   字符设备文件用于与系统中的字符设备进行通信，例如键盘、鼠标等。

5. `b`：块设备文件
   块设备文件用于与系统中的块设备进行通信，例如硬盘驱动器、USB设备等。

6. `p`：命名管道（FIFO）
   命名管道是一种特殊的文件类型，用于在进程之间传递数据。

7. `s`：套接字（Socket）
   套接字是一种特殊的文件类型，用于进程之间的网络通信。

这些字符通常显示在Linux系统中执行`ls -l`命令（或其变体）时文件权限的第一个字符位置。例如，一个文件的权限为 `-rw-r--r--`，**其中第一个字符就是 `-`，表示这是一个普通文件**。

------------------------------------------------

在Linux和类Unix系统中，文件和目录都有三种基本权限，分别是读取（Read）、写入（Write）和执行（Execute）权限。这些权限用于控制用户对**文件和目录**的访问和操作能力。每种权限都可以在三个不同的用户级别上设置：**所有者、所属组和其他用户**。

1. 读权限（Read）：
   - 对于文件：读权限允许用户查看文件的内容。如果没有读权限，则用户无法读取文件的内容。
   - 对于目录：读权限允许用户列出目录中的文件和子目录。如果没有读权限，则用户无法查看目录内容。

2. 写权限（Write）：
   - 对于文件：写权限允许用户修改文件的内容。如果没有写权限，则用户无法修改文件，文件内容将只读。
   - 对于目录：写权限允许用户在目录中创建、删除和重命名文件和子目录。如果没有写权限，则用户无法对目录进行修改。

3. 执行权限（Execute）：
   - 对于文件：执行权限对普通文件无意义，除非它被用作可执行程序。可执行程序必须具有执行权限，以便用户能够运行它们。
   - 对于目录：执行权限允许用户访问目录中的文件和子目录。如果没有执行权限，则用户无法进入目录。

在文件系统中，每个文件和目录都有一个拥有者（所有者）、所属组（组）和其他用户（其他）的权限设置。每种权限可以用数字或符号表示。

数字表示方式：
- 读权限：4
- 写权限：2
- 执行权限：1
- 无权限：0

符号表示方式：
- 读权限：r
- 写权限：w
- 执行权限：x
- 无权限：-

例如，`-rw-r--r--` 表示一个文件，所有者有读写权限，所属组和其他用户只有读权限。

要更改文件或目录的权限，可以使用`chmod`命令。例如，要将文件的权限设置为 `-rw-r--r--`，可以使用以下命令：`chmod 644 filename`。

------------------------------------------------
`ls -l` 是一个在Linux和类Unix系统中用于列出文件和目录的命令，它会以长格式（long format）显示文件的详细信息，包括文件的权限、所有者、所属组、大小、修改日期等。

输出的每一行代表一个文件或目录，具体的输出格式如下：

```
-rwxr-xr-x 1 username groupname size date filename
```

这里对输出进行逐个解释：

1. `-rwxr-xr-x`：这是文件的权限字段，显示了文件所有者、所属组和其他用户的权限。
   - 第一个字符表示文件类型：`-`表示普通文件，`d`表示目录，`l`表示符号链接，`b`表示块设备，`c`表示字符设备，`p`表示命名管道（FIFO），`s`表示套接字（socket）等。
   - 接下来的三个字符（`rwx`）表示文件所有者（owner）的读、写和执行权限。
   - 接着的三个字符（`r-x`）表示文件所属组（group）的读、写和执行权限。
   - 最后的三个字符（`r-x`）表示其他用户的读、写和执行权限。

2. `1`：这是链接计数，表示指向该文件或目录的硬链接数量。

3. `username`：这是文件的所有者，表示该文件属于哪个用户。

4. `groupname`：这是文件的所属组，表示该文件属于哪个用户组。

5. `size`：这是文件的大小，以字节为单位。

6. `date`：这是文件的最后修改日期和时间。

7. `filename`：这是文件的名称。

通过`ls -l`命令，你可以查看目录中文件的详细信息，包括权限、所有者、所属组、大小和修改日期等，帮助你更好地了解文件系统的状态和配置。

#### 35. 文件的特殊权限
在Linux系统中，**SUID、SGID和SBIT是用于设置文件或目录特殊权限的三个标志**。这些特殊权限标志可以与文件或目录的权限**一起使用**，以实现特定的权限控制和功能。这些标志在文件和目录的权限字段中以额外的方式表示。

1. SUID（Set User ID）：
   - 对于文件：当SUID标志设置在一个可执行文件上时，**表示在执行该文件时，进程将以文件所有者的权限运行，而不是执行该文件的用户的权限**。
   - 对于目录：在目录上设置SUID标志没有实际作用。

   表示SUID标志的符号是一个小写的 `s`，当没有执行权限时则为大写的 `S`。

2. SGID（Set Group ID）：
   - 对于文件：当SGID标志设置在一个可执行文件上时，**表示在执行该文件时，进程将以文件所属组的权限运行，而不是执行该文件的用户的权限。**
   - 对于目录：当SGID标志设置在一个目录上时，**表示在该目录下新创建的文件和目录将继承该目录的所属组，而不是创建者的默认组**。

   表示SGID标志的符号是一个小写的 `s`，当没有执行权限时则为大写的 `S`。

3. SBIT（Sticky Bit）：
   - 对于目录：当SBIT标志设置在一个目录上时，**表示只有文件的所有者、目录的所有者或超级用户才能删除在此目录下其他用户创建的文件，即保护目录中的文件不被其他非所有者用户删除**。

   表示SBIT标志的符号是一个小写的 `t`，当没有执行权限时则为大写的 `T`。

> 其实，**文件能否被删除并不取决于自身的权限，而是取决于其所在的目录的权限**。如果目录的权限允许用户删除文件，那么用户就可以删除该目录下的任何文件，即使文件的权限不允许用户删除它们。

#### 36. 文件的隐藏属性
Linux 系统中的文件除了具备一般权限和特殊权限之外，还有一种隐藏权限，即被隐藏起来的权限，默认情况下不能直接被用户发觉。
通过 `chattr` 和 `lsattr` 命令可以查看和设置文件的隐藏属性。

#### 37. 文件的访问控制列表
在Linux中，文件访问控制列表（Access Control List，ACL）是一种扩展的权限机制，**允许对文件和目录授予更精细的访问控制**。默认情况下，Linux使用基于所有者、所属组和其他用户的传统权限模型来控制文件和目录的访问权限。但是，有时候这种模型不够灵活，**特别是当涉及到多个用户或组需要不同权限时**，这就是ACL发挥作用的时候。

ACL允许管理员为**单个文件或目录中的多个用户和组设置不同的权限**。ACL可以为特定用户或组分配特定的权限，而不影响文件的其他用户和组的权限。这样，ACL提供了更细粒度的权限控制，增加了系统的灵活性。

基本的Linux文件ACL权限包括：

- `r`：读取权限（read）
- `w`：写入权限（write）
- `x`：执行权限（execute）

在访问控制列表中，每个用户或组可以被授予上述权限的任意组合。要使用ACL，文件系统必须以支持ACL的模式挂载。

常用的ACL相关命令：

1. `getfacl`：查看文件或目录的ACL权限。
2. `setfacl`：设置文件或目录的ACL权限。
3. `chmod`：设置基本权限，ACL权限的基础。

举例说明，假设有一个文件 `example.txt`，我们希望用户A拥有读取和写入权限，用户B拥有读取和执行权限，但是其他用户只能拥有读取权限。这样的ACL权限设置如下：

```
$ setfacl -m u:userA:rw- example.txt
$ setfacl -m u:userB:r-x example.txt
$ setfacl -m o::r-- example.txt
```

通过以上ACL设置，文件 `example.txt` 将具有以下权限：

```
-rw-r-----+ userA userB
```

**其中，`+` 符号表示ACL权限已经启用**。这样，用户A和用户B拥有了不同于其他用户的特定权限。

#### 38. su 命令与 sudo 服务
`su` 切换用户时，`su`命令与用户名之间有一个 `-` 符号，这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息。

> 当从 `root`管理员切换到普通用户时是不需要密码验证的，但是从普通用户切换到 `root` 管理员时需要密码验证。

-----------------------------------------------------

`visudo`是一个用于编辑`/etc/sudoers`文件的工具，在Linux系统中用于管理`sudo`服务的配置。`sudoers`文件包含了`sudo`服务的配置信息，其中定义了哪些用户或用户组被授权执行特定的命令以及以哪些身份执行这些命令。

使用`visudo`命令来编辑`sudoers`文件是非常重要的，因为该文件的权限设置需要非常谨慎。通过使用`visudo`，可以避免多个用户同时编辑`sudoers`文件导致的冲突，并且在保存后会对文件进行语法检查，以确保修改后的文件格式是正确的。

`visudo`使用了系统默认的文本编辑器，通常是Vi（Vim）编辑器。如果你对Vi编辑器不熟悉，当你执行`visudo`命令后，它会打开`sudoers`文件供你编辑。在`sudoers`文件中，你可以添加或修改用户或用户组的授权规则，指定允许执行哪些命令以及以哪个身份（用户或用户组）执行这些命令。

一些`sudoers`文件的示例配置：

```
# 允许用户A执行所有命令，不需要密码
userA ALL=(ALL) NOPASSWD: ALL

# 允许用户B以root权限执行特定命令，需要密码
userB ALL=(ALL) PASSWD: /usr/bin/command1, /usr/bin/command2

# 允许用户组C以root权限执行所有命令，需要密码
%groupC ALL=(ALL) PASSWD: ALL
```






#### 其它
`chmod u+x example.sh` 和 `chmod +x example.sh` 在大多数情况下是等效的，但它们有一个细微的区别：
1. `chmod u+x example.sh`: 这个指令中的 `u` 表示 "user"，也就是文件的拥有者，通常是当前登录的用户。这条命令会给文件 `example.sh` 的拥有者添加执行权限。
2. `chmod +x example.sh`: 这个指令中的 `+` 表示添加权限，但没有指定权限的接收者。这意味着这条命令会给文件 `example.sh` 的所有用户（拥有者、所属组、其他用户）都添加执行权限。

-----------------------------------------------------------

`dev/null` 是一个特殊的文件，它可以被用于丢弃不需要的输出流，或者作为一个空文件来对输出流重定向。如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 `/dev/null` 文件中。

-----------------------------------------------------------

在Linux系统中，`nologin`是一个特殊的系统用户帐户或Shell。它的目的是阻止特定用户登录到系统，并且通常用于防止一些帐户（如系统服务帐户）登录并交互式地执行命令。

主要使用场景包括：

1. 系统服务账户：一些系统服务在安装时会自动创建一个专用的用户帐户，以便安全地运行服务。为了防止这些服务帐户被误用或登录，通常将其登录Shell设置为`nologin`，从而阻止登录。

2. Shell限制：管理员可以将某些用户的Shell设置为`nologin`，以限制他们的登录权限。这可能是出于安全考虑，或者因为这些帐户只需要通过其他方式（如FTP、SCP等）进行访问。

3. 临时禁用帐户：在某些情况下，管理员可能需要暂时禁用用户帐户，而不是永久删除该帐户。将其Shell设置为`nologin`是一种临时禁用帐户的方法。

设置用户的登录Shell为`nologin`通常很简单，可以通过修改`/etc/passwd`文件来实现。管理员只需将用户的Shell字段设置为`/usr/sbin/nologin`或`/sbin/nologin`，具体取决于系统的配置。

> 请注意，`nologin`帐户仅影响交互式登录，而不会影响通过SSH密钥进行的非交互式操作或系统服务的正常运行。

-----------------------------------------------------------
用户的信息保存在`/etc/passwd`文件中，可以直接用文本编辑器来修改其中的用户参数项目，也可以使用`usermod`命令修改已经创建的用户信息。
`usermod` 的 `-d -m` 选项可重新指定用户的家目录**并自动把旧的数据转移过去**。

----------------------------------------------------------
在Linux和其他类Unix系统中，`uid`、`gid`和`groups`是用于标识和管理用户和用户组的概念，用于控制文件访问权限和资源管理。

1. UID（User ID）：
   - UID是用于唯一标识每个用户的整数值。每个用户都有一个独特的UID。
   - 0号UID对应的是超级用户账户，即"root"用户。root用户拥有系统中的最高权限。
   - UID为1至999的UID通常用于系统用户和服务账户，不应该用于一般用户登录。

2. GID（Group ID）：
   - GID是用于唯一标识每个用户组的整数值。每个用户组都有一个独特的GID。
   - 0号GID通常对应于"root"用户组，是系统中超级用户（root用户）的主要用户组。
   - GID为1至999的GID通常用于系统用户组和服务组。

3. Groups（用户组）：
   - 用户组是一组用户的集合，它允许系统管理员将一组用户归类在一起，并在组级别上设置权限。
   - 用户可以属于一个或多个用户组，允许他们共享相同的资源访问权限。
   - 用户组允许更有效地管理用户的权限，而不必为每个用户单独设置权限。

在Linux系统中，可以使用以下命令查看用户的UID、GID以及所属的用户组：

- `id`: 这个命令会显示当前用户的UID、GID以及所属的用户组。
- `groups`: 这个命令会显示当前用户所属的所有用户组。

例如，执行`id`命令可能会得到类似以下的输出：

```
uid=1000(username) gid=1000(username) groups=1000(username),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)
```

这表示当前用户的UID是1000，GID也是1000，同时还属于其他用户组，如adm、cdrom、sudo等。